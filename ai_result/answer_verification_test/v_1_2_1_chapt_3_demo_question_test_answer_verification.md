# Test objective

The objective of this test is to validate the **functional correctness and logical accuracy** of the answers generated by the LLM. 

While conceptual (non-code-based) questions are excluded from automated verification and require manual pedagogical review, all **code-based questions** must undergo instant validation. This ensures that any C code provided in questions, answers, or fill-in-the-blank snippets is logically sound, follows the C99 standard, and produces the expected output when executed.

# Methodology

We employ a bifurcated verification strategy based on the question type:

1.  **Conceptual Questions**: Verification is marked as "Manual Check Required." These are reviewed by subject matter experts to ensure distractor quality and factual accuracy.
2.  **Code-based Questions**: These are verified through **Instant Script Execution**. The LLM is required to provide a self-contained test environment for every code-based question.

**The Verification Process:**

| Step               | Action           | Description                                                                                          |
| :----------------- | :--------------- | :--------------------------------------------------------------------------------------------------- |
| **1. Generation**  | LLM Output       | The LLM generates the question and a copy-paste runnable `testScript` containing the solution logic. |
| **2. Extraction**  | Script Isolation | The `testScript` is extracted. It must include all headers (e.g., `<stdio.h>`), `main()`, and logic. |
| **3. Compilation** | C99 Environment  | The script is manually compiled and executed using a standard compiler.                              |
| **4. Comparison**  | Result Match     | The test passes if the execution output matches the `correctAnswer` provided in the JSON.            |

**Success Criteria:**
- **Code-based**: 100% Compilation success and logical match with the provided answer.
- **Standards**: All code must strictly adhere to the C99 standard.

# System Prompt

You are a senior professor of Data Structures with over 20 years of teaching experience. You are developing an LLM-driven automatic question-generation system strictly aligned with a provided knowledge point list.

### **STRICT CONSTRAINT: ATOMIC SCOPE GATING**
1. **The "All-or-Nothing" Rule**: When you receive a generation request, you must audit **all** requested items and concepts simultaneously. If **ANY** single item, keyword, or concept in the user's request is out-of-scope (e.g., "efficiency", "resizing"), you must reject the **ENTIRE** request. Do not provide a partial response.
2. **Definition of "Out-of-Scope"**:
   - Any term not explicitly in the list (e.g., "performance", "Big-O", "time complexity").
   - A request for "efficiency of insertion" is OUT-OF-SCOPE because the concept of "efficiency" is not in the knowledge points, even if "insertion" is.
3. **Rejection Protocol**: If an out-of-scope violation is detected, return ONLY:
```json
{
  "errorCode": "401",
  "errorMsg": "Knowledge required out of scope."
}
```
4. **Implicit Topic Selection (Random Generation)**: If the user's request specifies quantity and difficulty but does not mention any specific topic or keyword, you must NOT return an error. Instead, you must randomly and evenly select topics from the provided "knowledge point list" to fulfill the request. Ensure the generated questions are distributed across different topics in the list.

### **STRICT CONSTRAINT: CODE VERIFIABILITY & ANSWER VERIFICATION**

1. **C99 Standard**: All code snippets, answers, and test scripts must be written in standard C (C99).
2. **Instant Verification Script**: For every code-based question (code-based multiple-choice, code-based fill-in-the-blank, or code-based short-answer), you MUST provide a field named `"testScript"`.
3. **Script Completeness**: The `"testScript"` must be a complete, copy-paste runnable C program. It must include:
   - Necessary headers (e.g., `#include <stdio.h>`, `#include <stdlib.h>`).
   - The `main` function.
   - All logic required to demonstrate that the `correctAnswer` is indeed correct through instant execution.
4. **No External Tools**: Do not assume external testing frameworks. The script itself is the test.

**Specific Handling for Mixed Requests**
- **Example (Implicit Topic Selection)**:
  - User Instruction: "Generate 3 non-code-based multiple-choice questions, including: 1 hard, 2 easy."
  - Your Action: Since no out-of-scope terms are present, you should randomly pick topics (e.g., one from "Recursion", two from "Singly Linked Lists") from the list to generate the 3 questions.
- **Example (Mixed Request with Out-of-Scope)**:
  - User Instruction: "Generate 1 easy question on array indices, and 1 hard question on array efficiency."
  - Your Action: Because "efficiency" is not in the knowledge point list, you must reject both questions and return the 401 error code.

**General Rules**
1. Terminology Adherence: Use ONLY the course’s standard terminology as defined in the list (e.g., “singly linked list,” “header and trailer sentinels,” “linear recursion”).

2. Negative Example for Scope Rejection:
- User Instruction: "Generate 1 medium question about resizing arrays when full."
- Your Action: Since the list only mentions "fixed maximum size" and does not mention "resizing", you must return the 401 error JSON.

1. Logical Rigor: Ensure the logic is rigorous, correct, and unambiguous.

2. Difficulty definitions (based on Bloom’s Taxonomy):
   - easy (lower-order cognition): corresponds to Remember and Understand; only requires recalling facts, terms, or basic concepts, or providing simple explanations.
   - medium (mid-order cognition): corresponds to Apply and Analyze; requires applying knowledge in new situations or breaking down information to examine relationships.
   - hard (higher-order cognition): corresponds to Synthesize and Evaluate; requires making judgments based on standards or generating new ideas (e.g., designing, evaluating, synthesizing multi-step reasoning).

The output must be strictly an English JSON array. Each object has the following structure (all questions share base fields and expand dynamically depending on the question type):

Base fields (required for all questions):
```json
{
  "questionType": "multiple-choice | fill-in-the-blank | short-answer",
  "question": "full question text",
  "difficulty": "easy | medium | hard"
}
```

- multiple-choice (conceptual or code-based):
```json
{
  ...base fields,
  "answers": ["option A text", "option B text", "option C text", "option D text"] (exactly 4 options; randomly place the correct answer; do not include labels like A), B), etc.),
  "correctAnswer": index of the correct answer in the answers array (integer, starting from 0)
}
```

- fill-in-the-blank (conceptual or code-based):
```json
{
  ...base fields,
  "question": "full question text; use ___1___ for a single blank, or ___1___, ___2___ for multiple ordered blanks",
  "correctAnswer": ["correct blank answer 1", "correct blank answer 2", ...] (in blank order)
}
```

- short-answer (conceptual or code-based):
```json
{
  ...base fields,
  "correctAnswer": "the model standard answer (if code-based, provide a complete C code snippet with necessary comments)"
}
```

Important rules:

1. Absolutely do not output anything outside the JSON — no extra text or reasoning.

2. Multiple-choice distractors must be plausible but strictly incorrect.

3. All code-related content must be compilable standard C.

Now wait for the user to provide specific generation instructions.

# User Prompt Test + LLM Result

0. knowledge point list

Knowledge points list: `{knowledge_points_list}`

```json
[
  {
    "topic": "Using Arrays",
    "topic_knowledge_points": [
      "Arrays are concrete data structures that access their entries using integer indices.",
      "Arrays can be used to store objects like game entries with fixed maximum size.",
      "Insertion into an array involves shifting elements to make space for the new entry.",
      "Removal from an array involves shifting elements to fill the gap left by the removed entry.",
      "Insertion-sort algorithm sorts an array by inserting each element into the sorted prefix by shifting larger elements.",
      "Two-dimensional arrays use two indices to represent positional games, with row and column."
    ]
  },
  {
    "topic": "Singly Linked Lists",
    "topic_knowledge_points": [
      "A singly linked list is a collection of nodes that form a linear sequence, each node storing an element and a link to the next node.",
      "The head is the first node, and the tail is the last node with next pointer null.",
      "Insertion at the front of a singly linked list involves creating a new node and updating the head.",
      "Removal from the front of a singly linked list involves updating the head to the next node and deleting the old head.",
      "Singly linked lists can be implemented generically using templates to store arbitrary types."
    ]
  },
  {
    "topic": "Doubly Linked Lists",
    "topic_knowledge_points": [
      "A doubly linked list has nodes with next and prev pointers, allowing traversal in both directions.",
      "Header and trailer sentinels are dummy nodes at the beginning and end to simplify operations.",
      "Insertion into a doubly linked list involves linking a new node between two existing nodes by updating prev and next pointers.",
      "Removal from a doubly linked list involves linking out the node by updating prev and next of adjacent nodes.",
      "Doubly linked lists allow efficient insertion and removal at any position with direct access."
    ]
  },
  {
    "topic": "Circularly Linked Lists and List Reversal",
    "topic_knowledge_points": [
      "A circularly linked list links nodes in a cycle, with no beginning or end, using a cursor as a reference point.",
      "The back is the element at the cursor, and the front is the next element.",
      "Insertion in a circularly linked list adds after the cursor, handling the empty list by pointing to itself.",
      "Removal in a circularly linked list removes the node after the cursor.",
      "Reversing a linked list can be done by copying to a temporary list in reverse and copying back."
    ]
  },
  {
    "topic": "Recursion",
    "topic_knowledge_points": [
      "Recursion is when a function calls itself, with base cases to terminate and recursive cases to progress.",
      "Linear recursion makes at most one recursive call per invocation.",
      "Summing array elements can be done with linear recursion by adding the last element to the sum of the rest.",
      "Reversing an array can be done with linear recursion by swapping ends and recursing on the middle.",
      "Tail recursion is when the recursive call is the last operation, convertible to iteration.",
      "Binary recursion makes two recursive calls, like summing an array by splitting into halves.",
      "Computing Fibonacci naively with binary recursion is inefficient; it is better with linear recursion returning pairs.",
      "Multiple recursion makes more than two recursive calls, useful for enumerating configurations in puzzles."
    ]
  }
]
```

Example:

- Question: `{question}` `{level: medium}`  
  Which of the following best provides a recursive definition of a singly linked list?

  A) A collection of nodes where each node contains a data field and a pointer to the previous node in the sequence.  
  B) A data structure where each element is an object that contains a value and a reference to another data structure of the same type, or a null value.  
  C) A linear array of elements where each element's position is determined by its index and the size of the total list.  
  D) A set of nodes where the final node points back to the first node, creating a continuous loop of data.

- Answer: `{correctAnswer}`

  B)

1. Testing Code-based Answer Verification (Singly Linked List)

## Prompt
```md
Generate 1 code-based fill-in-the-blank question about removing a node from the front of a singly linked list.
```

## Expected Result
- A JSON object where correctAnswer matches the logic in `"testScript"`.
- `"testScript"` must compile and run in C99 to verify the removal logic.

## Actual Result
```json
[
  {
    "questionType": "fill-in-the-blank",
    "question": "Complete the following C function to remove the node from the front of a singly linked list. The function takes a pointer to the head pointer (`headPtr`) and returns the integer value stored in the removed node. Assume the list is non-empty and that nodes are of the following type:\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nint removeFront(Node** headPtr) {\n    Node* oldHead = ___1___;\n    int returnValue = oldHead->data;\n    *headPtr = ___2___;\n    ___3___;\n    return returnValue;\n}",
    "difficulty": "medium",
    "correctAnswer": ["*headPtr", "oldHead->next", "free(oldHead)"],
    "testScript": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nint removeFront(Node** headPtr) {\n    Node* oldHead = *headPtr;\n    int returnValue = oldHead->data;\n    *headPtr = oldHead->next;\n    free(oldHead);\n    return returnValue;\n}\n\nvoid printList(Node* head) {\n    while (head != NULL) {\n        printf(\"%d -> \", head->data);\n        head = head->next;\n    }\n    printf(\"NULL\\n\");\n}\n\nint main() {\n    // Create a sample list: 5 -> 10 -> 15 -> NULL\n    Node* head = (Node*)malloc(sizeof(Node));\n    head->data = 5;\n    head->next = (Node*)malloc(sizeof(Node));\n    head->next->data = 10;\n    head->next->next = (Node*)malloc(sizeof(Node));\n    head->next->next->data = 15;\n    head->next->next->next = NULL;\n    \n    printf(\"Original list: \");\n    printList(head);\n    \n    // Test the removeFront function with the correct answer\n    int removedValue = removeFront(&head);\n    printf(\"Removed value: %d\\n\", removedValue);\n    printf(\"List after removal: \");\n    printList(head);\n    \n    // Verify the removal was correct\n    if (removedValue == 5 && head != NULL && head->data == 10) {\n        printf(\"Test PASSED: Front node correctly removed.\\n\");\n    } else {\n        printf(\"Test FAILED.\\n\");\n    }\n    \n    // Clean up remaining nodes\n    while (head != NULL) {\n        Node* temp = head;\n        head = head->next;\n        free(temp);\n    }\n    \n    return 0;\n}"
  }
]
```


# Total test number
5