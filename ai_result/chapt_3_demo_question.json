{
  "question": "In your own words, explain the main difference between storing a sequence of elements in an array versus in a singly linked list. In your explanation, mention:\n(1) how we access the i-th element in each structure, and\n(2) what happens when we insert a new element at the front of the sequence in each structure.",
  "answer": "Model answer (conceptual explanation):\n\nAn **array** stores its elements in a single contiguous block of memory and uses **integer indices** for access. This means that accessing the i-th element is a **constant-time (O(1))** operation: we can compute its memory address directly as `base_address + i` and read it immediately.\n\nA **singly linked list** stores its elements in **nodes** that can be scattered in memory. Each node holds an element and a **link (pointer)** to the next node. To access the i-th element, we must **start at the head** and follow `next` pointers i times, so access is **linear-time (O(i))**.\n\nFor **insertion at the front**:\n- In an **array**, inserting at the front usually requires **shifting all existing elements one position to the right** to make room at index 0. This makes insertion at the front an **O(n)** operation in general.\n- In a **singly linked list**, inserting at the front only requires **creating a new node** and updating one pointer: we set the new nodeâ€™s `next` to the old head, and then update the head to this new node. This is an **O(1)** operation and does not require shifting existing elements.\n\nStep-by-step reasoning:\n1. Arrays are concrete data structures that access their entries using **integer indices** and store elements contiguously.\n2. Because of this contiguity and index arithmetic, the i-th element of an array is accessed in constant time.\n3. Singly linked lists are collections of **nodes** forming a linear sequence, where each node stores an element and a **link to the next node**.\n4. To reach the i-th node, we must follow `next` links one by one from the head, taking time proportional to i (linear-time access).\n5. When inserting at the front in an array, the new element must occupy index 0, so all current elements must be shifted right to free index 0.\n6. This shifting touches many elements, so the time grows with the number of elements n, giving O(n) time.\n7. In a singly linked list, the front is the **head node**, so to insert at the front we create a new node, set its `next` pointer to the current head, and then update the head variable to point to the new node.\n8. No shifting of existing elements is needed; only a constant number of pointer updates are performed, so insertion at the front is O(1).\n9. Therefore, arrays provide **fast random access but expensive front insertion**, while singly linked lists provide **slow random access but cheap front insertion**.\n",
  "difficulty": "1/5",
  "verification": "Check that the answer clearly distinguishes (1) access pattern and cost for the i-th element in arrays vs. singly linked lists, and (2) the steps and time cost of inserting at the front for both structures. Confirm that it correctly states: array random access is O(1), linked-list access is linear; front insertion is O(n) in an array (due to shifting) and O(1) in a singly linked list (due to pointer updates only). Ensure no claim suggests that linked lists support constant-time random access or that arrays avoid shifting on front insertion."
}
