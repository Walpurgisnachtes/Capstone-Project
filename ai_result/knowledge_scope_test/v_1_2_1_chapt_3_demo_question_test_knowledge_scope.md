# Test objective

The objective of this test is to validate the **strict adherence to the provided knowledge point list** in the questions generated by the LLM, ensuring no introduction of external concepts, terminology, algorithms, or complexity measures beyond the explicitly listed topics.

By enforcing a closed knowledge scope, we aim to guarantee content validity, curriculum alignment, and assessment fairness. This test evaluates whether the "Senior Professor" agent can generate questions—particularly at medium and hard difficulty levels—that remain fully grounded in the supplied knowledge points, even when prompted to maximize coverage or create comparative/trade-off questions that could tempt the model to leak out-of-scope material (e.g., time complexity notation, dynamic resizing, STL implementations).

# Methodology

To verify scope fidelity, we employ a systematic content auditing process combining automated keyword detection and expert review.

| Audit Category                  | Examples of Forbidden Elements (Out-of-Scope)                | Permitted Elements                                        |
| ------------------------------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| Performance/Complexity Notation | Big-O, O(1), O(n), amortized analysis, time/space complexity | Operational descriptions (e.g., shifting elements)        |
| Dynamic Array Features          | Resizing, capacity vs. size, vector growth, reallocation     | Fixed maximum size only                                   |
| Additional Structural Features  | Size counters, length fields (not in knowledge points)       | Pointer updates, sentinels (only for doubly linked lists) |
| Cross-Structure Contamination   | Header/trailer sentinels in singly linked lists              | Sentinels restricted to doubly linked lists               |
| Advanced Concepts               | Cache-friendliness, memory locality, fragmentation           | Pointer manipulations, recursion types                    |

**The Validation Process:**

1. **Generation:** The model generates a targeted set of questions using a neutral but coverage-maximizing prompt designed to stress scope boundaries.
2. **Scope Auditing:** Each question is examined for the presence of any forbidden term, concept, or implication not explicitly present in the knowledge point list.
3. **Classification:** Questions are labeled as "Clean" (fully within scope) or "Contaminated" (contains out-of-scope material).
4. **Quantitative Metric:** Compute Knowledge Scope Fidelity Rate (KSFR) = (Number of Clean Questions / Total Questions) × 100%.
5. **Comparison:** The test passes if KSFR = 100% (or ≥ 98% for larger samples); any contamination indicates failure of the knowledge-gating mechanism.

This method aligns with established practices in automated question generation and assessment validity research, where strict content bounding prevents construct-irrelevant variance.

# System Prompt

You are a senior professor of Data Structures with over 20 years of teaching experience. You are developing an LLM-driven automatic question-generation system strictly aligned with a provided knowledge point list.

### **STRICT CONSTRAINT: ATOMIC SCOPE GATING**
1. **The "All-or-Nothing" Rule**: When you receive a generation request, you must audit **all** requested items and concepts simultaneously. If **ANY** single item, keyword, or concept in the user's request is out-of-scope (e.g., "efficiency", "resizing"), you must reject the **ENTIRE** request. Do not provide a partial response.
2. **Definition of "Out-of-Scope"**:
   - Any term not explicitly in the list (e.g., "performance", "Big-O", "time complexity").
   - A request for "efficiency of insertion" is OUT-OF-SCOPE because the concept of "efficiency" is not in the knowledge points, even if "insertion" is.
3. **Rejection Protocol**: If an out-of-scope violation is detected, return ONLY:
```json
{
  "errorCode": "401",
  "errorMsg": "Knowledge required out of scope."
}
```
4. **Implicit Topic Selection (Random Generation)**: If the user's request specifies quantity and difficulty but does not mention any specific topic or keyword, you must NOT return an error. Instead, you must randomly and evenly select topics from the provided "knowledge point list" to fulfill the request. Ensure the generated questions are distributed across different topics in the list.

**Specific Handling for Mixed Requests**
- **Example (Implicit Topic Selection)**:
  - User Instruction: "Generate 3 non-code-based multiple-choice questions, including: 1 hard, 2 easy."
  - Your Action: Since no out-of-scope terms are present, you should randomly pick topics (e.g., one from "Recursion", two from "Singly Linked Lists") from the list to generate the 3 questions.
- **Example (Mixed Request with Out-of-Scope)**:
  - User Instruction: "Generate 1 easy question on array indices, and 1 hard question on array efficiency."
  - Your Action: Because "efficiency" is not in the knowledge point list, you must reject both questions and return the 401 error code.

**General Rules**
1. Terminology Adherence: Use ONLY the course’s standard terminology as defined in the list (e.g., “singly linked list,” “header and trailer sentinels,” “linear recursion”).

2. Negative Example for Scope Rejection:
- User Instruction: "Generate 1 medium question about resizing arrays when full."
- Your Action: Since the list only mentions "fixed maximum size" and does not mention "resizing", you must return the 401 error JSON.

3. Logical Rigor: Ensure the logic is rigorous, correct, and unambiguous.

4. Difficulty definitions (based on Bloom’s Taxonomy):
   - easy (lower-order cognition): corresponds to Remember and Understand; only requires recalling facts, terms, or basic concepts, or providing simple explanations.
   - medium (mid-order cognition): corresponds to Apply and Analyze; requires applying knowledge in new situations or breaking down information to examine relationships.
   - hard (higher-order cognition): corresponds to Synthesize and Evaluate; requires making judgments based on standards or generating new ideas (e.g., designing, evaluating, synthesizing multi-step reasoning).

5. C Language Standards: If a question involves code, it must explicitly state the language is C (C99), and it must provide a complete, copy-paste runnable test script.

The output must be strictly an English JSON array. Each object has the following structure (all questions share base fields and expand dynamically depending on the question type):

Base fields (required for all questions):
```json
{
  "questionType": "multiple-choice | fill-in-the-blank | short-answer",
  "question": "full question text",
  "difficulty": "easy | medium | hard"
}
```

- multiple-choice (conceptual or code-based):
```json
{
  ...base fields,
  "answers": ["option A text", "option B text", "option C text", "option D text"] (exactly 4 options; randomly place the correct answer; do not include labels like A), B), etc.),
  "correctAnswer": index of the correct answer in the answers array (integer, starting from 0)
}
```

- fill-in-the-blank (conceptual or code-based):
```json
{
  ...base fields,
  "question": "full question text; use ___1___ for a single blank, or ___1___, ___2___ for multiple ordered blanks",
  "correctAnswer": ["correct blank answer 1", "correct blank answer 2", ...] (in blank order)
}
```

- short-answer (conceptual or code-based):
```json
{
  ...base fields,
  "correctAnswer": "the model standard answer (if code-based, provide a complete C code snippet with necessary comments)"
}
```

If a question is code-based (code-based multiple-choice, code-based fill-in-the-blank, or code-based short-answer), you must additionally include:
- `"testScript"`: a complete, copy-paste runnable C test script (including `main`, required headers, compilable and runnable to verify correctness)

Important rules:

1. Absolutely do not output anything outside the JSON — no extra text or reasoning.

2. Multiple-choice distractors must be plausible but strictly incorrect.

3. All code-related content must be compilable standard C.

Now wait for the user to provide specific generation instructions.

# User Prompt Test + LLM Result

0. knowledge point list and example question

Knowledge points list: `{knowledge_points_list}`

```json
[
  {
    "topic": "Using Arrays",
    "topic_knowledge_points": [
      "Arrays are concrete data structures that access their entries using integer indices.",
      "Arrays can be used to store objects like game entries with fixed maximum size.",
      "Insertion into an array involves shifting elements to make space for the new entry.",
      "Removal from an array involves shifting elements to fill the gap left by the removed entry.",
      "Insertion-sort algorithm sorts an array by inserting each element into the sorted prefix by shifting larger elements.",
      "Two-dimensional arrays use two indices to represent positional games, with row and column."
    ]
  },
  {
    "topic": "Singly Linked Lists",
    "topic_knowledge_points": [
      "A singly linked list is a collection of nodes that form a linear sequence, each node storing an element and a link to the next node.",
      "The head is the first node, and the tail is the last node with next pointer null.",
      "Insertion at the front of a singly linked list involves creating a new node and updating the head.",
      "Removal from the front of a singly linked list involves updating the head to the next node and deleting the old head.",
      "Singly linked lists can be implemented generically using templates to store arbitrary types."
    ]
  },
  {
    "topic": "Doubly Linked Lists",
    "topic_knowledge_points": [
      "A doubly linked list has nodes with next and prev pointers, allowing traversal in both directions.",
      "Header and trailer sentinels are dummy nodes at the beginning and end to simplify operations.",
      "Insertion into a doubly linked list involves linking a new node between two existing nodes by updating prev and next pointers.",
      "Removal from a doubly linked list involves linking out the node by updating prev and next of adjacent nodes.",
      "Doubly linked lists allow efficient insertion and removal at any position with direct access."
    ]
  },
  {
    "topic": "Circularly Linked Lists and List Reversal",
    "topic_knowledge_points": [
      "A circularly linked list links nodes in a cycle, with no beginning or end, using a cursor as a reference point.",
      "The back is the element at the cursor, and the front is the next element.",
      "Insertion in a circularly linked list adds after the cursor, handling the empty list by pointing to itself.",
      "Removal in a circularly linked list removes the node after the cursor.",
      "Reversing a linked list can be done by copying to a temporary list in reverse and copying back."
    ]
  },
  {
    "topic": "Recursion",
    "topic_knowledge_points": [
      "Recursion is when a function calls itself, with base cases to terminate and recursive cases to progress.",
      "Linear recursion makes at most one recursive call per invocation.",
      "Summing array elements can be done with linear recursion by adding the last element to the sum of the rest.",
      "Reversing an array can be done with linear recursion by swapping ends and recursing on the middle.",
      "Tail recursion is when the recursive call is the last operation, convertible to iteration.",
      "Binary recursion makes two recursive calls, like summing an array by splitting into halves.",
      "Computing Fibonacci naively with binary recursion is inefficient; it is better with linear recursion returning pairs.",
      "Multiple recursion makes more than two recursive calls, useful for enumerating configurations in puzzles."
    ]
  }
]
```

Example:

- Question: `{question}` `{level: medium}`  
  Which of the following best provides a recursive definition of a singly linked list?

  A) A collection of nodes where each node contains a data field and a pointer to the previous node in the sequence.  
  B) A data structure where each element is an object that contains a value and a reference to another data structure of the same type, or a null value.  
  C) A linear array of elements where each element's position is determined by its index and the size of the total list.  
  D) A set of nodes where the final node points back to the first node, creating a continuous loop of data.

- Answer: `{correctAnswer}`

  B)

1. Testing Out-of-Scope Concept

## Prompt
```md
{{knowledge point list and example question}}

Generate 1 non-code-based multiple-choice questions, including:  
- 1 medium, about resizing arrays when full
```

## Expected Result
```json
{
  "errorCode": "401",
  "errorMsg": "Knowledge required out of scope."
}
```

## Actual Result
```json
{
  "errorCode": "401",
  "errorMsg": "Knowledge required out of scope."
}
```

2. Testing Combining Out-Of-Scope Concept + In-Scope Concept

## Prompt

```md
Generate 2 non-code-based multiple-choice questions, including:  
- 1 hard, about efficiency of insertion
- 1 easy, about definition of arrays
```

## Expected Result
```json
{
  "errorCode": "401",
  "errorMsg": "Knowledge required out of scope."
}
```

## Actual Result
```json
{
  "errorCode": "401",
  "errorMsg": "Knowledge required out of scope."
}
```

1. Testing Unspecified Concept

## Prompt

```md
Generate 3 non-code-based multiple-choice questions, including:  
- 1 hard
- 2 easy
```

## Expected Result
```json
[
  {
    "question": "hard question 1",
  },
  {
    "question": "easy question 1",
  },
  {
    "question": "easy question 2",
  }
]

```

## Actual Result
```json
[
    {
        "questionType": "multiple-choice",
        "question": "In the context of reversing an array using linear recursion, what is the primary logical relationship that must be established between the recursive call and the base case to ensure all elements are correctly swapped?",
        "difficulty": "hard",
        "answers": [
            "The base case handles arrays of size 0 or 1 where no swap is needed, and the recursive case swaps the first and last elements before recursing on the inner subarray.",
            "The base case handles the entire array by iterating through all indices, and the recursive case is used only if an error is detected in the order.",
            "The recursive call is made first to process the entire array, and the base case performs the swap after all calls return.",
            "The base case is defined for an array of maximum size, and the recursive case randomly selects two indices to swap before making the call."
        ],
        "correctAnswer": 0
    },
    {
        "questionType": "multiple-choice",
        "question": "In a two-dimensional array used to represent a positional game, what do the two indices typically represent?",
        "difficulty": "easy",
        "answers": [
            "The memory address and the data type of the element.",
            "The row and the column of the game board.",
            "The previous and next node pointers.",
            "The head and tail of a linked list."
        ],
        "correctAnswer": 1
    },
    {
        "questionType": "multiple-choice",
        "question": "What characterizes a tail recursive function?",
        "difficulty": "easy",
        "answers": [
            "It makes two recursive calls per invocation.",
            "The recursive call is the last operation performed in the function before returning.",
            "It requires a sentinel node to terminate.",
            "It always operates on a circular data structure."
        ],
        "correctAnswer": 1
    }
]
```

# Reference

```bib
@book{Biggs2011,
  author = {Biggs, John B. and Tang, Catherine},
  title = {Teaching for Quality Learning at University},
  edition = {4th},
  year = {2011},
  publisher = {Open University Press},
  address = {Maidenhead}
}

@inproceedings{Mitkov2019,
  author = {Mitkov, Ruslan and Lee, Min and Ha, Le An},
  title = {Automatic Question Generation: A Review of Methodologies, Datasets and Evaluation},
  booktitle = {Proceedings of the 12th International Conference on Natural Language Generation},
  year = {2019},
  pages = {1--10}
}
```
