{
  "chapter_code": "Chapter 4",
  "chapter_title": "Analysis Tools",
  "knowledge_points": [
    {
      "topic": "The Seven Functions Used in This Book",
      "topic_knowledge_points": [
        "The constant function f(n) = c assigns a fixed value regardless of n and characterizes basic computer operations.",
        "The logarithm function log_b n measures the number of times n can be divided by b until reaching 1 and often appears in divide-and-conquer algorithms.",
        "The linear function f(n) = n represents performing a single basic operation for each of n elements in a data structure.",
        "The n-log-n function f(n) = n log n grows slightly faster than linear and is common in efficient sorting algorithms.",
        "The quadratic function f(n) = n^2 arises from nested loops each iterating linearly over n elements.",
        "The cubic function f(n) = n^3 and other polynomials describe running times where operations are raised to higher powers of n.",
        "The exponential function f(n) = b^n models scenarios where the number of operations multiplies by a constant factor each step."
      ]
    },
    {
      "topic": "Analysis of Algorithms",
      "topic_knowledge_points": [
        "Experimental studies measure algorithm running times by executing them on test inputs and recording elapsed time.",
        "Primitive operations include assignments, comparisons, and arithmetic computations that take constant time.",
        "Asymptotic notation focuses on the growth rate of running times for large input sizes, ignoring constant factors.",
        "Big-Oh notation O(g(n)) bounds the running time from above for sufficiently large n.",
        "Asymptotic analysis typically considers the worst-case running time to provide performance guarantees.",
        "Recursive algorithms like computing powers can be analyzed by considering base cases and recursive calls."
      ]
    },
    {
      "topic": "Simple Justification Techniques",
      "topic_knowledge_points": [
        "Justification by example demonstrates a property holds for specific cases but does not prove it generally.",
        "The contra attack disproves a claim by providing a counterexample where the claim fails.",
        "Induction proves a statement for all natural numbers by verifying base cases and the inductive step.",
        "Loop invariants maintain a true condition before and after each iteration to prove loop correctness."
      ]
    }
  ],
  "exercises": [
    {
      "topic_exercise": {
        "reinforcement": [
          {
            "exercise_code": "R-4.1",
            "exercise_content": "There is a well-known city (which will go nameless here) whose inhabitants have the reputation of enjoying a meal only if that meal is the best they have ever experienced in their life. Otherwise, they hate it. Assuming meal quality is distributed uniformly across a person’s life, what is the expected number of times inhabitants of this city are happy with their meals?"
          },
          {
            "exercise_code": "R-4.2",
            "exercise_content": "Give a pseudo-code description of the O(n)-time algorithm for computing the power function p(x,n). Also, draw the recursion trace of this algorithm for the computation of p(2,5)."
          },
          {
            "exercise_code": "R-4.3",
            "exercise_content": "Give a C++ description of Algorithm Power for computing the power function p(x,n) (Code Fragment 4.4)."
          },
          {
            "exercise_code": "R-4.4",
            "exercise_content": "Draw the recursion trace of the Power algorithm (Code Fragment 4.4, which computes the power function p(x,n)) for computing p(2,9)."
          },
          {
            "exercise_code": "R-4.5",
            "exercise_content": "Analyze the running time of Algorithm BinarySum (Code Fragment 3.41) for arbitrary values of the input parameter n."
          },
          {
            "exercise_code": "R-4.6",
            "exercise_content": "Graph the functions 8n, 4nlogn, 2n2, n3, and 2n using a logarithmic scale for the x- and y-axes. That is, if the function is f(n) is y, plot this as a point with x-coordinate at logn and y-coordinate at logy."
          },
          {
            "exercise_code": "R-4.7",
            "exercise_content": "The number of operations executed by algorithms A and B is 8nlogn and 2n2, respectively. Determine n0 such that A is better than B for n ≥n0."
          },
          {
            "exercise_code": "R-4.8",
            "exercise_content": "The number of operations executed by algorithms A and B is 40n2 and 2n3, respectively. Determine n0 such that A is better than B for n ≥n0."
          },
          {
            "exercise_code": "R-4.9",
            "exercise_content": "Give an example of a function that is plotted the same on a log-log scale as it is on a standard scale."
          },
          {
            "exercise_code": "R-4.10",
            "exercise_content": "Explain why the plot of the function nc is a straight line with slope c on a log-log scale."
          },
          {
            "exercise_code": "R-4.11",
            "exercise_content": "What is the sum of all the even numbers from 0 to 2n, for any positive integer n?"
          },
          {
            "exercise_code": "R-4.12",
            "exercise_content": "Show that the following two statements are equivalent: (a) The running time of algorithm A is always O( f(n)). (b) In the worst case, the running time of algorithm A is O( f(n))."
          },
          {
            "exercise_code": "R-4.13",
            "exercise_content": "Order the following functions by asymptotic growth rate. 4nlogn+2n 210 2logn 3n+100logn 4n 2n n2 +10n n3 nlogn"
          },
          {
            "exercise_code": "R-4.14",
            "exercise_content": "Show that if d(n) is O( f(n)), then ad(n) is O( f(n)), for any constant a > 0."
          },
          {
            "exercise_code": "R-4.15",
            "exercise_content": "Show that if d(n) is O( f(n)) and e(n) is O(g(n)), then the product d(n)e(n) is O( f(n)g(n))."
          },
          {
            "exercise_code": "R-4.16",
            "exercise_content": "Give a big-Oh characterization, in terms of n, of the running time of the Ex1 function shown in Code Fragment 4.6."
          },
          {
            "exercise_code": "R-4.17",
            "exercise_content": "Give a big-Oh characterization, in terms of n, of the running time of the Ex2 function shown in Code Fragment 4.6."
          },
          {
            "exercise_code": "R-4.18",
            "exercise_content": "Give a big-Oh characterization, in terms of n, of the running time of the Ex3 function shown in Code Fragment 4.6."
          },
          {
            "exercise_code": "R-4.19",
            "exercise_content": "Give a big-Oh characterization, in terms of n, of the running time of the Ex4 function shown in Code Fragment 4.6."
          },
          {
            "exercise_code": "R-4.20",
            "exercise_content": "Give a big-Oh characterization, in terms of n, of the running time of the Ex5 function shown in Code Fragment 4.6."
          },
          {
            "exercise_code": "R-4.21",
            "exercise_content": "Bill has an algorithm, find2D, to find an element x in an n × n array A. The algorithm find2D iterates over the rows of A, and calls the algorithm arrayFind, of Code Fragment 4.5, on each row, until x is found or it has searched all rows of A. What is the worst-case running time of find2D in terms of n? What is the worst-case running time of find2D in terms of N, where N is the total size of A? Would it be correct to say that Find2D is a linear-time algorithm? Why or why not?"
          },
          {
            "exercise_code": "R-4.22",
            "exercise_content": "For each function f(n) and time t in the following table, determine the largest size n of a problem P that can be solved in time t if the algorithm for solving P takes f(n) microseconds (one entry is already completed). 1 Second 1 Hour 1 Month 1 Century logn ≈10300000 n nlogn n2 2n"
          },
          {
            "exercise_code": "R-4.23",
            "exercise_content": "Show that if d(n) is O( f(n)) and e(n) is O(g(n)), then d(n) + e(n) is O( f(n)+g(n))."
          },
          {
            "exercise_code": "R-4.24",
            "exercise_content": "Show that if d(n) is O( f(n)) and e(n) is O(g(n)), then d(n)−e(n) is not necessarily O( f(n)−g(n))."
          },
          {
            "exercise_code": "R-4.25",
            "exercise_content": "Show that if d(n) is O( f(n)) and f(n) is O(g(n)), then d(n) is O(g(n))."
          },
          {
            "exercise_code": "R-4.26",
            "exercise_content": "Show that O(max{f(n),g(n)}) = O( f(n)+g(n))."
          },
          {
            "exercise_code": "R-4.27",
            "exercise_content": "Show that f(n) is O(g(n)) if and only if g(n) is Ω( f(n))."
          },
          {
            "exercise_code": "R-4.28",
            "exercise_content": "Show that if p(n) is a polynomial in n, then log p(n) is O(logn)."
          },
          {
            "exercise_code": "R-4.29",
            "exercise_content": "Show that (n+1)5 is O(n5)."
          },
          {
            "exercise_code": "R-4.30",
            "exercise_content": "Show that 2n+1 is O(2n)."
          },
          {
            "exercise_code": "R-4.31",
            "exercise_content": "Show that n is O(nlogn)."
          },
          {
            "exercise_code": "R-4.32",
            "exercise_content": "Show that n2 is Ω(nlogn)."
          },
          {
            "exercise_code": "R-4.33",
            "exercise_content": "Show that nlogn is Ω(n)."
          },
          {
            "exercise_code": "R-4.34",
            "exercise_content": "Show that ⌈f(n)⌉is O( f(n)), if f(n) is a positive nondecreasing function that is always greater than 1."
          },
          {
            "exercise_code": "R-4.35",
            "exercise_content": "Algorithm A executes an O(logn)-time computation for each entry of an n-element array. What is the worst-case running time of Algorithm A?"
          },
          {
            "exercise_code": "R-4.36",
            "exercise_content": "Given an n-element array X, Algorithm B chooses logn elements in X at random and executes an O(n)-time calculation for each. What is the worst-case running time of Algorithm B?"
          },
          {
            "exercise_code": "R-4.37",
            "exercise_content": "Given an n-element array X of integers, Algorithm C executes an O(n)-time computation for each even number in X, and an O(logn)-time computation for each odd number in X. What are the best-case and worst-case running times of Algorithm C?"
          },
          {
            "exercise_code": "R-4.38",
            "exercise_content": "Given an n-element array X, Algorithm D calls Algorithm E on each element X[i]. Algorithm E runs in O(i) time when it is called on element X[i].What is the worst-case running time of Algorithm D?"
          },
          {
            "exercise_code": "R-4.39",
            "exercise_content": "Al and Bob are arguing about their algorithms. Al claims his O(nlogn)-time method is always faster than Bob’s O(n2)-time method. To settle the issue, they perform a set of experiments. To Al’s dismay, they find that if n < 100, the O(n2)-time algorithm runs faster, and only when n ≥100 is the O(nlogn)-time one better. Explain how this is possible."
          }
        ],
        "creativity": [
          {
            "exercise_code": "C-4.1",
            "exercise_content": "Describe a recursive algorithm to compute the integer part of the base-2 logarithm of n using only addition and integer division."
          },
          {
            "exercise_code": "C-4.2",
            "exercise_content": "Describe an efficient recursive method for solving the element uniqueness problem, which runs in time that is at most O(n2) in the worst case without using sorting."
          },
          {
            "exercise_code": "C-4.3",
            "exercise_content": "Assuming it is possible to sort n numbers in O(nlogn) time, show that it is possible to solve the three-way set disjointness problem in O(nlogn) time."
          },
          {
            "exercise_code": "C-4.4",
            "exercise_content": "Describe an efficient algorithm for finding the 10 largest elements in an array of size n. What is the running time of your algorithm?"
          },
          {
            "exercise_code": "C-4.5",
            "exercise_content": "Suppose you are given an n-element array A containing distinct integers that are listed in increasing order. Given a number k, describe a recursive algorithm to find two integers in A that sum to k, if such a pair exists. What is the running time of your algorithm?"
          },
          {
            "exercise_code": "C-4.6",
            "exercise_content": "Given an n-element unsorted array A of n integers and an integer k, describe a recursive algorithm for rearranging the elements in A so that all elements less than or equal to k come before any elements larger than k. What is the running time of your algorithm?"
          },
          {
            "exercise_code": "C-4.7",
            "exercise_content": "Communication security is extremely important in computer networks, and one way many network protocols achieve security is to encrypt messages. Typical cryptographic schemes for the secure transmission of messages over such networks are based on the fact that no efficient algorithms are known for factoring large integers. Hence, if we can represent a secret message by a large prime number p, we can transmit, over the network, the number r = p·q, where q > p is another large prime number that acts as the encryption key. An eavesdropper who obtains the transmitted number r on the network would have to factor r in order to figure out the secret message p. Using factoring to figure out a message is very difficult without knowing the encryption key q. To understand why, consider the following naive factoring algorithm: for p = 2,···,r −1 do if p divides r then return “The secret message is p!” a. Suppose that the eavesdropper uses the above algorithm and has a computer that can carry out in 1 microsecond (1 millionth of a second) a division between two integers of up to 100 bits each. Give an estimate of the time that it will take in the worst case to decipher the secret message p if the transmitted message r has 100 bits. b. What is the worst-case time complexity of the above algorithm? Since the input to the algorithm is just one large number r, assume that the input size n is the number of bytes needed to store r, that is, n = ⌊(log2 r)/8⌋+1, and that each division takes time O(n)."
          },
          {
            "exercise_code": "C-4.8",
            "exercise_content": "Give an example of a positive function f(n) such that f(n) is neither O(n) nor Ω(n)."
          },
          {
            "exercise_code": "C-4.9",
            "exercise_content": "Show that ∑n i=1 i2 is O(n3)."
          },
          {
            "exercise_code": "C-4.10",
            "exercise_content": "Show that ∑n i=1 i/2i < 2. (Hint: Try to bound this sum term by term with a geometric progression.)"
          },
          {
            "exercise_code": "C-4.11",
            "exercise_content": "Show that logb f(n) is Θ(log f(n)) if b > 1 is a constant."
          },
          {
            "exercise_code": "C-4.12",
            "exercise_content": "Describe a method for finding both the minimum and maximum of n numbers using fewer than 3n/2 comparisons. (Hint: First construct a group of candidate minimums and a group of candidate maximums.)"
          },
          {
            "exercise_code": "C-4.13",
            "exercise_content": "Bob built a Web site and gave the URL only to his n friends, which he numbered from 1 to n. He told friend number i that he/she can visit the Web site at most i times. Now Bob has a counter, C, keeping track of the total number of visits to the site (but not the identities of who visits). What is the minimum value for C such that Bob should know that one of his friends has visited his/her maximum allowed number of times?"
          },
          {
            "exercise_code": "C-4.14",
            "exercise_content": "Al says he can prove that all sheep in a flock are the same color: Base case: One sheep. It is clearly the same color as itself. Induction step: A flock of n sheep. Take a sheep, a, out. The remaining n −1 are all the same color by induction. Now put sheep a back in and take out a different sheep, b. By induction, the n−1 sheep (now with a) are all the same color. Therefore, all the sheep in the flock are the same color. What is wrong with Al’s “justification”?"
          },
          {
            "exercise_code": "C-4.15",
            "exercise_content": "Consider the following “justification” that the Fibonacci function, F(n) (see Proposition 4.20) is O(n): Base case (n ≤2): F(1) = 1 and F(2) = 2. Induction step (n > 2): Assume the claim true for n′ < n. Consider n. F(n) = F(n −1) + F(n −2). By induction, F(n −1) is O(n −1) and F(n−2) is O(n−2). Then, F(n) is O((n−1)+(n−2)), by the identity presented in Exercise R-4.23. Therefore, F(n) is O(n). What is wrong with this “justification”?"
          },
          {
            "exercise_code": "C-4.16",
            "exercise_content": "Let p(x) be a polynomial of degree n, that is, p(x) = ∑n i=0 aixi. (a) Describe a simple O(n2) time method for computing p(x). (b) Now consider a rewriting of p(x) as p(x) = a0 +x(a1 +x(a2 +x(a3 +···+x(an−1 +xan)···))), which is known as Horner’s method. Using the big-Oh notation, characterize the number of arithmetic operations this method executes."
          },
          {
            "exercise_code": "C-4.17",
            "exercise_content": "Consider the Fibonacci function, F(n) (see Proposition 4.20). Show by induction that F(n) is Ω((3/2)n)."
          },
          {
            "exercise_code": "C-4.18",
            "exercise_content": "Given a set A = {a1,a2,...,an} of n integers, describe, in pseudo-code, an efficient method for computing each of partial sums sk = ∑k i=1 ai, for k = 1,2,...,n. What is the running time of this method?"
          },
          {
            "exercise_code": "C-4.19",
            "exercise_content": "Draw a visual justification of Proposition 4.3 analogous to that of Figure 4.1(b) for the case when n is odd."
          },
          {
            "exercise_code": "C-4.20",
            "exercise_content": "An array A contains n −1 unique integers in the range [0,n −1], that is, there is one number from this range that is not in A. Design an O(n)-time algorithm for finding that number. You are only allowed to use O(1) additional space besides the array A itself."
          },
          {
            "exercise_code": "C-4.21",
            "exercise_content": "Let S be a set of n lines in the plane such that no two are parallel and no three meet in the same point. Show, by induction, that the lines in S determine Θ(n2) intersection points."
          },
          {
            "exercise_code": "C-4.22",
            "exercise_content": "Show that the summation ∑n i=1⌈log2 i⌉is O(nlogn)."
          },
          {
            "exercise_code": "C-4.23",
            "exercise_content": "An evil king has n bottles of wine, and a spy has just poisoned one of them. Unfortunately, they don’t know which one it is. The poison is very deadly; just one drop diluted even a billion to one will still kill. Even so, it takes a full month for the poison to take effect. Design a scheme for determining exactly which one of the wine bottles was poisoned in just one month’s time while expending O(logn) taste testers."
          },
          {
            "exercise_code": "C-4.24",
            "exercise_content": "An array A contains n integers taken from the interval [0,4n], with repetitions allowed. Describe an efficient algorithm for determining an integer value k that occurs the most often in A. What is the running time of your algorithm?"
          },
          {
            "exercise_code": "C-4.25",
            "exercise_content": "Describe, in pseudo-code, a method for multiplying an n × m matrix A and an m× p matrix B. Recall that the product C = AB is defined so that C[i][ j] = ∑m k=1 A[i][k]·B[k][ j]. What is the running time of your method?"
          },
          {
            "exercise_code": "C-4.26",
            "exercise_content": "Suppose each row of an n×n array A consists of 1’s and 0’s such that, in any row i of A, all the 1’s come before any 0’s. Also suppose that the number of 1’s in row i is at least the number in row i+1, for i = 0,1,...,n−2. Assuming A is already in memory, describe a method running in O(n) time (not O(n2)) for counting the number of 1’s in A."
          },
          {
            "exercise_code": "C-4.27",
            "exercise_content": "Describe a recursive function for computing the nth Harmonic number, Hn = ∑n i=1 1/i."
          }
        ],
        "projects": [
          {
            "exercise_code": "P-4.1",
            "exercise_content": "Implement prefixAverages1 and prefixAverages2 from Section 4.2.5, and perform an experimental analysis of their running times. Visualize their running times as a function of the input size with a log-log chart."
          },
          {
            "exercise_code": "P-4.2",
            "exercise_content": "Perform a careful experimental analysis that compares the relative running times of the functions shown in Code Fragments 4.6."
          },
          {
            "exercise_code": "P-4.3",
            "exercise_content": "Perform an experimental analysis to test the hypothesis that the STL function, sort, runs in O(nlogn) time on average."
          },
          {
            "exercise_code": "P-4.4",
            "exercise_content": "Perform an experimental analysis to determine the largest value of n for each of the three algorithms given in the chapter for solving the element uniqueness problem such that the given algorithm runs in one minute or less."
          }
        ]
      }
    }
  ]
}